true
  : Bool
false
  : Bool
42
  : Nat
1
  : Nat
false
  : Bool
x : Bool
x
  : Bool
lambda x':Bool. x'
  : Bool -> Bool
true
  : Bool
id = lambda x':Bool. x'
  : Bool -> Bool
true
  : Bool
CBool = Nat -> Nat -> Nat
tru = lambda t:Nat. lambda f:Nat. t
  : CBool
fls = lambda t:Nat. lambda f:Nat. f
  : CBool
test = lambda l:CBool. lambda m:Nat. lambda n:Nat. l m n
  : CBool -> Nat -> Nat -> Nat
33
  : Nat
CPair = CBool -> Nat
pair = lambda f:Nat. lambda s:Nat. (lambda b:CBool. b f s) as CPair
  : Nat -> Nat -> CPair
fst = lambda p:CPair. p tru
  : CPair -> Nat
snd = lambda p:CPair. p fls
  : CPair -> Nat
33
  : Nat
CNat = (Nat -> Nat) -> Nat -> Nat
c0 = lambda s:Nat->Nat. lambda z:Nat. z
  : CNat
c1 = lambda s:Nat->Nat. lambda z:Nat. s z
  : CNat
c2 = lambda s:Nat->Nat. lambda z:Nat. s (s z)
  : CNat
c3 = lambda s:Nat->Nat. lambda z:Nat. s (s (s z))
  : CNat
scc = lambda n:CNat. (lambda s:Nat->Nat. lambda z:Nat. s (n s z)) as CNat
  : CNat -> CNat
lambda s:Nat->Nat. lambda z:Nat. s ((lambda s':Nat->Nat. lambda z':Nat. s' z') s z)
  : CNat
plus = lambda m:CNat. lambda n:CNat. (lambda s:Nat->Nat. lambda z:Nat. m s (n s z)) as CNat
  : CNat -> CNat -> CNat
lambda s:Nat->Nat. lambda z:Nat. (lambda s':Nat->Nat. lambda z':Nat. s' (s' z')) s ((lambda s':Nat->Nat. lambda z':Nat. s' (s' z')) s z)
  : CNat
realnat = lambda m:CNat. m (lambda x':Nat. (succ x')) 0
  : CNat -> Nat
3
  : Nat
4
  : Nat
lambda x':A. x'
  : A -> A
lambda x':B. x'
  : B -> B
lambda f:A->A. lambda x':A. f (f x')
  : (A -> A) -> A -> A
unit
  : Unit
42
  : Nat
UU = Unit -> Unit
unit
  : Unit
lambda f:Unit->Unit. f
  : UU -> UU
{3, false}
  : {Nat, Bool}
3
  : Nat
4
  : Nat
{partno=55, cost=30}
  : {partno:Nat, cost:Nat}
{cost=30, partno=55}
  : {cost:Nat, partno:Nat}
PhysicalAddr = {firstlast:String, addr:String}
VirtualAddr = {name:String, email:String}
pa = {firstlast="AC", addr="EG"}
  : {firstlast:String, addr:String}
va = {name="AC", email="AC@edu"}
  : {name:String, email:String}
Addr = <physical:PhysicalAddr, virtual:VirtualAddr>
a = <physical={firstlast="AC", addr="EG"}> as Addr
  : Addr
getName = lambda a':Addr. case a' of <physical=x'>==>x'.firstlast | <virtual=y>==>y.name
  : Addr -> String
equal = lambda x':Nat. lambda y:Nat. if iszero x' then if iszero y then true elsefalse elseif iszero y then false elsefix (lambda eq:Nat->Nat->Bool. lambda x'':Nat. lambda y':Nat. if iszero x'' then if iszero y' then true elsefalse elseif iszero y' then false elseeq (pred x'') (pred y')) (pred x') (pred y)
  : Nat -> Nat -> Bool
OptionNat = <none:Unit, some:Nat>
Table = Nat -> OptionNat
emptyTable = lambda n:Nat. <none=unit> as OptionNat
  : Nat -> OptionNat
extendTable = lambda t:Table. lambda m:Nat. lambda v:Nat. (lambda n:Nat. if equal n m then <some=v> as OptionNat elset n) as Table
  : Table -> Nat -> Nat -> Table
Weekday = <monday:Unit, tuesday:Unit, wednesday:Unit, thursday:Unit, friday:Unit>
nextBusinessDay = lambda w:Weekday. case w of <monday=x'>==><tuesday=unit> as Weekday | <tuesday=x'>==><wednesday=unit> as Weekday | <wednesday=x'>==><thursday=unit> as Weekday | <thursday=x'>==><friday=unit> as Weekday | <friday=x'>==><monday=unit> as Weekday
  : Weekday -> Weekday
<tuesday=unit> as Weekday
  : Weekday
<monday=unit> as Weekday
  : Weekday
DollarAmount = <dollars:Double>
EuroAmount = <euros:Double>
dollars2euros = lambda d:DollarAmount. case d of <dollars=x'>==><euros=timesdouble x' 1.1325> as EuroAmount
  : DollarAmount -> EuroAmount
euros2dollars = lambda e:EuroAmount. case e of <euros=x'>==><dollars=timesdouble x' 0.883> as DollarAmount
  : EuroAmount -> DollarAmount
mybankbalance = <dollars=39.5> as DollarAmount
  : DollarAmount
<dollars=39.49990125> as DollarAmount
  : DollarAmount
ff = lambda ie:Nat->Bool. lambda x':Nat. if iszero x' then true elseif iszero (pred x') then false elseie (pred (pred x'))
  : (Nat -> Bool) -> Nat -> Bool
iseven = lambda x':Nat. if iszero x' then true elseif iszero (pred x') then false elsefix (lambda ie:Nat->Bool. lambda x'':Nat. if iszero x'' then true elseif iszero (pred x'') then false elseie (pred (pred x''))) (pred (pred x'))
  : Nat -> Bool
false
  : Bool
ff = lambda ieio:{iseven:Nat->Bool,isodd:Nat->Bool}. {iseven=lambda x':Nat. if iszero x' then true elseieio.isodd (pred x'), isodd=lambda x':Nat. if iszero x' then false elseieio.iseven (pred x')}
  : {iseven:Nat->Bool, isodd:Nat->Bool} -> {iseven:Nat->Bool, isodd:Nat->Bool}
r = {iseven=lambda x':Nat. if iszero x' then true else(fix (lambda ieio:{iseven:Nat->Bool,isodd:Nat->Bool}. {iseven=lambda x'':Nat. if iszero x'' then true elseieio.isodd (pred x''), isodd=lambda x'':Nat. if iszero x'' then false elseieio.iseven (pred x'')})).isodd (pred x'), isodd=lambda x':Nat. if iszero x' then false else(fix (lambda ieio:{iseven:Nat->Bool,isodd:Nat->Bool}. {iseven=lambda x'':Nat. if iszero x'' then true elseieio.isodd (pred x''), isodd=lambda x'':Nat. if iszero x'' then false elseieio.iseven (pred x'')})).iseven (pred x')}
  : {iseven:Nat->Bool, isodd:Nat->Bool}
iseven = lambda x':Nat. if iszero x' then true else(fix (lambda ieio:{iseven:Nat->Bool,isodd:Nat->Bool}. {iseven=lambda x'':Nat. if iszero x'' then true elseieio.isodd (pred x''), isodd=lambda x'':Nat. if iszero x'' then false elseieio.iseven (pred x'')})).isodd (pred x')
  : Nat -> Bool
false
  : Bool
diverge = lambda _:Unit. fix (lambda x':T. x')
  : Unit -> T
NList = Rec X. <nil:Unit, cons:{Nat,X}>
NLBody = <nil:Unit, cons:{Nat,NList}>
nil = fold [NList] <nil=unit> as NLBody
  : NList
cons = lambda n:Nat. lambda l:NList. fold [NList] <cons={n, l}> as NLBody
  : Nat -> NList -> NList
isnil = lambda l:NList. case unfold [NList] l of <nil=u>==>true | <cons=p>==>false
  : NList -> Bool
hd = lambda l:NList. case unfold [NList] l of <nil=u>==>0 | <cons=p>==>p.1
  : NList -> Nat
tl = lambda l:NList. case unfold [NList] l of <nil=u>==>l | <cons=p>==>p.2
  : NList -> NList
plus = lambda x':Nat. lambda y:Nat. if iszero x' then y else(succ (fix (lambda p:Nat->Nat->Nat. lambda x'':Nat. lambda y':Nat. if iszero x'' then y' else(succ (p (pred x'') y'))) (pred x') y))
  : Nat -> Nat -> Nat
sumlist = lambda l:NList. if isnil l then 0 elseplus (hd l) (fix (lambda s:NList->Nat. lambda l':NList. if isnil l' then 0 elseplus (hd l') (s (tl l'))) (tl l))
  : NList -> Nat
mylist = fold [NList] <cons={2, fold [NList] <cons={3, fold [NList] <cons={5, fold [NList] <nil=unit> as NLBody}> as NLBody}> as NLBody}> as NLBody
  : NList
10
  : Nat
Hungry = Rec A. Nat -> A
f = fold [Hungry] (lambda n:Nat. fold [Hungry] (fix (lambda f:Nat->Hungry. lambda n':Nat. fold [Hungry] f)))
  : Hungry
fold [Hungry] (lambda n:Nat. fold [Hungry] (fix (lambda f':Nat->Hungry. lambda n':Nat. fold [Hungry] f')))
  : Hungry
Stream = Rec A. Unit -> {Nat, A}
hd = lambda s:Stream. (unfold [Stream] s unit).1
  : Stream -> Nat
tl = lambda s:Stream. (unfold [Stream] s unit).2
  : Stream -> Stream
upfrom0 = fold [Stream] (lambda _:Unit. {0, fix (lambda f':Nat->Stream. lambda n:Nat. fold [Stream] (lambda _':Unit. {n, f' (succ n)})) 1})
  : Stream
0
  : Nat
3
  : Nat
Process = Rec A. Nat -> {Nat, A}
p = fold [Process] (lambda n:Nat. (lambda newacc:Nat. {newacc, fix (lambda f':Nat->Process. lambda acc:Nat. fold [Process] (lambda n':Nat. (lambda newacc':Nat. {newacc', f' newacc'}) (plus acc n'))) newacc}) (plus 0 n))
  : Process
curr = lambda s:Process. (unfold [Process] s 0).1
  : Process -> Nat
send = lambda n:Nat. lambda s:Process. (unfold [Process] s n).2
  : Nat -> Process -> Process
28
  : Nat
Counter = Rec C. {get:Nat, inc:Unit->C, dec:Unit->C}
create = lambda s:{x:Nat}. fold [Counter] {get=s.x, inc=lambda _:Unit. fix (lambda f':{x:Nat}->Counter. lambda s':{x:Nat}. fold [Counter] {get=s'.x, inc=lambda _':Unit. f' {x=(succ s'.x)}, dec=lambda _':Unit. f' {x=pred s'.x}}) {x=(succ s.x)}, dec=lambda _:Unit. fix (lambda f':{x:Nat}->Counter. lambda s':{x:Nat}. fold [Counter] {get=s'.x, inc=lambda _':Unit. f' {x=(succ s'.x)}, dec=lambda _':Unit. f' {x=pred s'.x}}) {x=pred s.x}}
  : {x:Nat} -> Counter
c = fold [Counter] {get=0, inc=lambda _:Unit. fix (lambda f':{x:Nat}->Counter. lambda s:{x:Nat}. fold [Counter] {get=s.x, inc=lambda _':Unit. f' {x=(succ s.x)}, dec=lambda _':Unit. f' {x=pred s.x}}) {x=(succ {x=0}.x)}, dec=lambda _:Unit. fix (lambda f':{x:Nat}->Counter. lambda s:{x:Nat}. fold [Counter] {get=s.x, inc=lambda _':Unit. f' {x=(succ s.x)}, dec=lambda _':Unit. f' {x=pred s.x}}) {x=pred {x=0}.x}}
  : Counter
c1 = fold [Counter] {get=1, inc=lambda _:Unit. fix (lambda f':{x:Nat}->Counter. lambda s:{x:Nat}. fold [Counter] {get=s.x, inc=lambda _':Unit. f' {x=(succ s.x)}, dec=lambda _':Unit. f' {x=pred s.x}}) {x=(succ {x=1}.x)}, dec=lambda _:Unit. fix (lambda f':{x:Nat}->Counter. lambda s:{x:Nat}. fold [Counter] {get=s.x, inc=lambda _':Unit. f' {x=(succ s.x)}, dec=lambda _':Unit. f' {x=pred s.x}}) {x=pred {x=1}.x}}
  : Counter
c2 = fold [Counter] {get=2, inc=lambda _:Unit. fix (lambda f':{x:Nat}->Counter. lambda s:{x:Nat}. fold [Counter] {get=s.x, inc=lambda _':Unit. f' {x=(succ s.x)}, dec=lambda _':Unit. f' {x=pred s.x}}) {x=(succ {x=2}.x)}, dec=lambda _:Unit. fix (lambda f':{x:Nat}->Counter. lambda s:{x:Nat}. fold [Counter] {get=s.x, inc=lambda _':Unit. f' {x=(succ s.x)}, dec=lambda _':Unit. f' {x=pred s.x}}) {x=pred {x=2}.x}}
  : Counter
2
  : Nat
_fix = lambda f':T->T. (lambda x':Rec A. A->T. f' (unfold [Rec A. A->T] x' x')) fold [Rec A. A->T] (lambda x':Rec A. A->T. f' (unfold [Rec A. A->T] x' x'))
  : (T -> T) -> T
diverge = lambda _:Unit. _fix (lambda x':T. x')
  : Unit -> T
D = Rec X. X -> X
dlam = lambda f':D->D. fold [D] f'
  : (D -> D) -> D
dapp = lambda f':D. lambda a':D. unfold [D] f' a'
  : D -> D -> D
dfix = fold [D] (lambda f':D. dapp (dlam (lambda x':D. dapp f' (dapp x' x'))) (dlam (lambda x':D. dapp f' (dapp x' x'))))
  : D
