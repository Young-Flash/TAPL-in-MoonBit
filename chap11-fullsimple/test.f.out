true
  : Bool
false
  : Bool
42
  : Nat
1
  : Nat
false
  : Bool
x : Bool
x
  : Bool
lambda x':Bool. x'
  : Bool -> Bool
true
  : Bool
id = lambda x':Bool. x'
  : Bool -> Bool
true
  : Bool
CBool = Nat -> Nat -> Nat
tru = lambda t:Nat. lambda f:Nat. t
  : CBool
fls = lambda t:Nat. lambda f:Nat. f
  : CBool
test = lambda l:CBool. lambda m:Nat. lambda n:Nat. l m n
  : CBool -> Nat -> Nat -> Nat
33
  : Nat
CPair = CBool -> Nat
pair = lambda f:Nat. lambda s:Nat. (lambda b:CBool. b f s) as CPair
  : Nat -> Nat -> CPair
fst = lambda p:CPair. p tru
  : CPair -> Nat
snd = lambda p:CPair. p fls
  : CPair -> Nat
33
  : Nat
CNat = (Nat -> Nat) -> Nat -> Nat
c0 = lambda s:Nat->Nat. lambda z:Nat. z
  : CNat
c1 = lambda s:Nat->Nat. lambda z:Nat. s z
  : CNat
c2 = lambda s:Nat->Nat. lambda z:Nat. s (s z)
  : CNat
c3 = lambda s:Nat->Nat. lambda z:Nat. s (s (s z))
  : CNat
scc = lambda n:CNat. (lambda s:Nat->Nat. lambda z:Nat. s (n s z)) as CNat
  : CNat -> CNat
lambda s:Nat->Nat. lambda z:Nat. s ((lambda s':Nat->Nat. lambda z':Nat. s' z') s z)
  : CNat
plus = lambda m:CNat. lambda n:CNat. (lambda s:Nat->Nat. lambda z:Nat. m s (n s z)) as CNat
  : CNat -> CNat -> CNat
lambda s:Nat->Nat. lambda z:Nat. (lambda s':Nat->Nat. lambda z':Nat. s' (s' z')) s ((lambda s':Nat->Nat. lambda z':Nat. s' (s' z')) s z)
  : CNat
realnat = lambda m:CNat. m (lambda x':Nat. (succ x')) 0
  : CNat -> Nat
3
  : Nat
4
  : Nat
lambda x':A. x'
  : A -> A
lambda x':B. x'
  : B -> B
lambda f:A->A. lambda x':A. f (f x')
  : (A -> A) -> A -> A
unit
  : Unit
42
  : Nat
UU = Unit -> Unit
unit
  : Unit
lambda f:Unit->Unit. f
  : UU -> UU
{3, false}
  : {Nat, Bool}
3
  : Nat
4
  : Nat
{partno=55, cost=30}
  : {partno:Nat, cost:Nat}
{cost=30, partno=55}
  : {cost:Nat, partno:Nat}
PhysicalAddr = {firstlast:String, addr:String}
VirtualAddr = {name:String, email:String}
pa = {firstlast="AC", addr="EG"}
  : {firstlast:String, addr:String}
va = {name="AC", email="AC@edu"}
  : {name:String, email:String}
Addr = <physical:PhysicalAddr, virtual:VirtualAddr>
a = <physical={firstlast="AC", addr="EG"}> as Addr
  : Addr
getName = lambda a':Addr. case a' of <physical=x'>==>x'.firstlast | <virtual=y>==>y.name
  : Addr -> String
equal = lambda x':Nat. lambda y:Nat. if iszero x' then if iszero y then true elsefalse elseif iszero y then false elsefix (lambda eq:Nat->Nat->Bool. lambda x'':Nat. lambda y':Nat. if iszero x'' then if iszero y' then true elsefalse elseif iszero y' then false elseeq (pred x'') (pred y')) (pred x') (pred y)
  : Nat -> Nat -> Bool
OptionNat = <none:Unit, some:Nat>
Table = Nat -> OptionNat
emptyTable = lambda n:Nat. <none=unit> as OptionNat
  : Nat -> OptionNat
extendTable = lambda t:Table. lambda m:Nat. lambda v:Nat. (lambda n:Nat. if equal n m then <some=v> as OptionNat elset n) as Table
  : Table -> Nat -> Nat -> Table
Weekday = <monday:Unit, tuesday:Unit, wednesday:Unit, thursday:Unit, friday:Unit>
nextBusinessDay = lambda w:Weekday. case w of <monday=x'>==><tuesday=unit> as Weekday | <tuesday=x'>==><wednesday=unit> as Weekday | <wednesday=x'>==><thursday=unit> as Weekday | <thursday=x'>==><friday=unit> as Weekday | <friday=x'>==><monday=unit> as Weekday
  : Weekday -> Weekday
<tuesday=unit> as Weekday
  : Weekday
<monday=unit> as Weekday
  : Weekday
DollarAmount = <dollars:Double>
EuroAmount = <euros:Double>
dollars2euros = lambda d:DollarAmount. case d of <dollars=x'>==><euros=timesdouble x' 1.1325> as EuroAmount
  : DollarAmount -> EuroAmount
euros2dollars = lambda e:EuroAmount. case e of <euros=x'>==><dollars=timesdouble x' 0.883> as DollarAmount
  : EuroAmount -> DollarAmount
mybankbalance = <dollars=39.5> as DollarAmount
  : DollarAmount
<dollars=39.49990125> as DollarAmount
  : DollarAmount
ff = lambda ie:Nat->Bool. lambda x':Nat. if iszero x' then true elseif iszero (pred x') then false elseie (pred (pred x'))
  : (Nat -> Bool) -> Nat -> Bool
iseven = lambda x':Nat. if iszero x' then true elseif iszero (pred x') then false elsefix (lambda ie:Nat->Bool. lambda x'':Nat. if iszero x'' then true elseif iszero (pred x'') then false elseie (pred (pred x''))) (pred (pred x'))
  : Nat -> Bool
false
  : Bool
ff = lambda ieio:{iseven:Nat->Bool,isodd:Nat->Bool}. {iseven=lambda x':Nat. if iszero x' then true elseieio.isodd (pred x'), isodd=lambda x':Nat. if iszero x' then false elseieio.iseven (pred x')}
  : {iseven:Nat->Bool, isodd:Nat->Bool} -> {iseven:Nat->Bool, isodd:Nat->Bool}
r = {iseven=lambda x':Nat. if iszero x' then true else(fix (lambda ieio:{iseven:Nat->Bool,isodd:Nat->Bool}. {iseven=lambda x'':Nat. if iszero x'' then true elseieio.isodd (pred x''), isodd=lambda x'':Nat. if iszero x'' then false elseieio.iseven (pred x'')})).isodd (pred x'), isodd=lambda x':Nat. if iszero x' then false else(fix (lambda ieio:{iseven:Nat->Bool,isodd:Nat->Bool}. {iseven=lambda x'':Nat. if iszero x'' then true elseieio.isodd (pred x''), isodd=lambda x'':Nat. if iszero x'' then false elseieio.iseven (pred x'')})).iseven (pred x')}
  : {iseven:Nat->Bool, isodd:Nat->Bool}
iseven = lambda x':Nat. if iszero x' then true else(fix (lambda ieio:{iseven:Nat->Bool,isodd:Nat->Bool}. {iseven=lambda x'':Nat. if iszero x'' then true elseieio.isodd (pred x''), isodd=lambda x'':Nat. if iszero x'' then false elseieio.iseven (pred x'')})).isodd (pred x')
  : Nat -> Bool
false
  : Bool
diverge = lambda _:Unit. fix (lambda x':T. x')
  : Unit -> T
